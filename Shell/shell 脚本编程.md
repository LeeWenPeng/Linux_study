## 1. 解释器

解释器位置

+ `/bin/bash`：默认解释器

查询解释器所在位置

```shell
cat /etc/shells
```

## 2. 脚本后缀

### 2.1. 后缀名不影响脚本文件的执行

通常，`shell` 脚本后缀的名称为`.sh`。但，**脚本后缀其实并不影响脚本的执行**。

+ `.sh` 是一种惯例，用来表明文件是 **Shell 脚本**。它提高了文件的 **可读性** 和 **可维护性**，帮助用户或开发者快速了解文件的用途。

### 2.2. 后缀的命名原则

1 见名知意

+ 文件名应清晰描述脚本的功能。
+ 使用合适的后缀（如 `.sh`、`.py`、`.pl`）表明脚本类型，便于识别。

2 简化后缀

**生产环境中**：对脚本名进行简化，去掉后缀，让脚本表现得像一个命令。

```bash
mv backup.sh /usr/local/bin/backup
```

这样用户可以通过命令 `backup` 直接运行，而无需关心后缀。

## 3. shengbang

`#!` 用于指定脚本文件的**解释器路径**，告诉系统应该用哪个解释器运行脚本。也称为 `shengbang` 。

语法

```shell
# 1 动态查找解释器
#!/usr/bin/env 解释器名称
...

# 2 明确指定解释器路径
#!解释器路径
...
```

+ 如果脚本未指定 `#!`，脚本执行时，默认用当前 shell 去解释脚本，即 `shell`
+ 如果 `#!` 指定了可执行的解释器，脚本执行时，会将脚本名称作为参数传递给解释器
	+ 如果`#!`指定的解释器没有可执行权限，则会报错：权限拒绝
	+ 如果`#!`指定的解释器不存在，则会报错：不存在该文件或文件夹

### 3.1. 明确指定解释器路径

适合特定环境，启动效率高

```shell
#!/bin/bash
```

+ 不会查找`PATH`

### 3.2. 动态查找解释器 -- 推荐

通过 `PATH` 查找系统中的`sh`解释器

```shell
#!/usr/bin/env sh
```

 + 可以自动查找系统中的 `sh` 解释器，避免硬编码特定路径，这种方法对跨平台脚本开发特别有用。
+ 完全依赖 `PATH` ，存在查找开销
+ 如果`PATH` 设置不正确，将找不到所需的解释器

## 4. 运行shell 脚本

Linux 系统通过文件的 **(`#!`)** 和 **文件权限** 来决定如何执行脚本，而非依赖文件后缀。在具体的执行方式上，通常有如下三种：

+ **`source`/`.`**
+ **`sh`/`bash`**
+ **`./`**

### 4.1. **`source` (或 `.`)**

通过`source` 或 `.` 命令来执行脚本文件

语法

```bash
source FileName
# 或
. FileName
```

+ **在当前 Shell 环境中执行**，不会启动子 Shell。
+ 执行时，脚本中的命令直接在当前 Shell 环境下生效。
+ **无需执行权限**，只需要脚本具有可读权限。

常见用途

1. **加载配置文件**：如 `.bashrc` 或 `.profile`。
2. **定义函数或变量**：将脚本中的变量、函数直接引入当前 Shell 环境。

>[!note] 注意事项
>+ 脚本中的修改（如变量定义、路径更改）会直接影响当前 Shell 会话。

### 4.2. **`sh` 或 `bash`**

将脚本作为指定解释器执行参数

语法

```bash
sh [options] FileName
# 或
bash [options] FileName
```

+ `-vx`：调试执行
+ **启动子 Shell** 来执行脚本，不影响当前 Shell 环境。
+ 脚本文件只需要具备 **可读权限**，无需执行权限。

>[!note]
>+ 使用的解释器可能与脚本 `#!` 指定的解释器不同，可能导致兼容性问题。
>+ 因此，通过这种方式执行的脚本中不需要（不建议）指定解释器

### 4.3. **`./`**

通过赋予脚本文件执行权限，可以直接执行该脚本

语法

```bash
./FileName
```

本质：**启动子 Shell** 来执行脚本。

要求：

+ **需要执行权限**（`chmod +x FileName`）。
+ 使用脚本内的 `#!` 指定的解释器运行脚本。

### 4.4. **总结对比**

| **方式**      | **是否需要执行权限** | **是否启动子 Shell** | **是否使用脚本内指定的解释器**  | **影响当前 Shell** |
| ----------- | ------------ | --------------- | ------------------ | -------------- |
| `source`    | 否            | 否               | 否                  | 是              |
| `sh`/`bash` | 否            | 是               | 否（固定为 `sh`/`bash`） | 否              |
| `./`        | 是            | 是               | 是                  | 否              |

**选择使用的方式通常取决于：**
1. 是否需要脚本对当前环境生效（用 `source`）。
2. 是否希望脚本运行在独立环境中（用 `sh`/`bash` 或 `./`）。
3. 是否希望尊重脚本中定义的解释器（用 `./`）。

## 5. Shell 变量

在 Shell 编程中，变量是用于存储数据值的名称。Shell 变量分为两种：

+ 系统变量
+ 用户自定义变量

### 5.1. 系统环境变量

可以直接使用`$`符访问环境变量

语法

```shell
$环境变量名称
```

常用系统变量

```shell
$SHELL # 系统解释器
$PATH # 路径
$HOME # 用户目录
$PWD # 当前目录
$USER # 当前用户
```

#### 5.1.1. 临时环境变量

通过 `export` 命令在本 shell 内将用户自定义变量提升为环境变量

```bash
export variable=value
```

+ 仅在当前 Shell 会话中有效，仅是临时有效

#### 5.1.2. 环境变量编写

1. 将`export`语句写入到配置文件之中
2. 重载配置文件
	1. `source 配置文件`
	2. `. 配置文件`
	3. 重启电脑

### 5.2. 用户自定义变量

#### 5.2.1. 变量的定义

定义变量时，变量名不加美元符号（$，PHP语言中变量需要）。

语法：

```shell
# 1
variable_name=value

# 2 双引号 -- 建议！
variable_name="value"

# 3
variable_name='value'
```

+ value 中有空格时，需要用引号包含

>[!note]
>在 Shell中，**变量通常被视为字符串**。通过使用单引号 ' 或双引号 " 来定义字符串。

>[!important] 对变量进行定义时，等号两侧避免使用无效空格
> + 错误定义：`variable = value`
> + 正确定义：`variable=value`

>[!note] 变量命名规则
>+ 只包含字母、数字和下划线 。
> + 不能以数字开头
> + 避免使用 Shell 关键字。
> + 使用大写字母表示常量和系统环境变量。
> + 避免使用特殊符号，防止可能与 Shell 的语法产生的冲突。
> + 避免使用空格，空格也是特殊符号，通常用于分隔命令和参数。

#### 5.2.2. 变量的赋值

##### \= 符号

普通赋值

```shell
variable=value
```

##### := 符号

条件赋值：如果变量未定义或为空值，则为其赋值。

```shell
variable:=value
```

##### read 读入

```shell
read variables

read -p "message" variables
```

+ 详情请见 [[Shell 命令2#2.1. read 命令]]

#### 5.2.3. 变量的使用

使用一个定义过的变量，只要在变量名前面加美元符号即可

```shell
$variable_name

# 可以使用花括号将变量名框选起来
${variable_name} # 推荐
```

#### 5.2.4. 静态变量

使用 `readonly` 命令可以将变量定义为只读变量，只读变量的值不能被改变。

语法

```shell
readonly variable_name
```

#### 5.2.5. 变量取消定义

使用 `unset` 命令可以删除变量。语法：

```shell
unset variable_name
```

+ 变量被删除后不能再次使用。
+ unset 命令不能删除只读变量

#### 5.2.6. 作用域

Shell自定义变量的作用域默认为全局

通过 `local` 命令可以将脚本作用域限制在函数体内

```shell
function_name(){
	local variable=value
}
```

### 5.3. 位置变量-`$n`

可以在执行脚本时，向脚本传递参数，传递的参数由脚本内变量接收。

语法

```shell
$1 $2 ... $n

# 当参数超过 10 后
... ${10} ${11} ... ${n}
```

+ n 代表一个数，代表第 n 个参数
+ 传递的参数从 1 开始
	+ `$0`：为执行文件名（包含文件路径）
+ 10 个及以上的参数需要使用`{}`包含
	+ **通常脚本需要输入参数不应该超过 4个**

>[!note]
>在为shell脚本传递的参数中**如果包含空格，应该使用单引号或者双引号将该参数括起来，以便于脚本将这个参数作为整体来接收**。

### 5.4. 预定义变量

#### 5.4.1. 常用特殊变量

| 语法   | 说明                                                                   |
| ---- | -------------------------------------------------------------------- |
| `$0` | 执行文件名（带路径，取决于执行脚本时的输入）                                               |
| `$#` | 传递到脚本的参数个数                                                           |
| `$*` | 以一个**单字符串**显示所有向脚本传递的参数。`"*"` <-> `"1 2 … n"`                        |
| `$@` | 与`$*`相同，但是使用时加引号，并在引号中返回**每个参数**。`"@"` <-> `"1" "2" "3" … "n"`--推荐使用 |
| `$$` | 脚本运行的**当前进程的 PID**                                                   |
| `$!` | **后台**运行的最后一个进程的 PID 号                                               |
| `$?` | 显示最后命令的退出状态。**0表示没有错误，其他任何值表明有错误**。(判断上一行语句是否有正确执行)                  |
| `$-` | 显示Shell使用的当前选项，与set命令功能相同。                                           |

#### 5.4.2. `$*` 和 `$@` 的异同

| 特性      | `$*`                   | `$@`                   |
| ------- | ---------------------- | ---------------------- |
| 未加引号的行为 | 将所有参数合并成单个字符串，参数用空格分隔。 | 将所有参数合并成单个字符串，参数用空格分隔。 |
| 加引号的行为  | 所有参数合并成单个字符串，参数用空格分隔。  | 每个参数保持独立，逐个保留原始值。      |

+ 推荐使用`$@`

## 6. 字符串变量

### 6.1. 引号

#### 6.1.1. 单引号

单引号的限制：

+ 除字符串拼接外，**单引号里的任何字符都会原样输出**，直接存在的单引号字符串中的变量和转义字符是无效的（强引用）
+ 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。
+ 需要使用符号本意时，推荐使用单引号，否则推荐双引号。

#### 6.1.2. 双引号

双引号的优点：

+ 双引号里可以有**变量**
+ 双引号里可以出现**转义字符**

#### 6.1.3. 反引号

命令替换，将其中的字符串作为 shell 命令执行。

等价于 `$(…)` —— 推荐使用!

**反引号中的 shell 命令会被先执行。**

### 6.2. 字符串拼接

通过变量进行字符串拼接

```shell
# 1
v1_new = 's1 '${v1_old}''
# 2
v2_new = 's2 ${v2_old}'
# 3
v3_new = "s3 ${v3_old}"
# 4
v4_new = "s4 "${v4_old}""
```

+ 单引号字符串中，不能直接使用变量，如`2`中的变量会被当成普通字符。正确做法是`1`中的，通过内嵌单引号使用变量

### 6.3. 获取字符串长度

#### 6.3.1. `#`

```shell
${#variable_name}
```

#### 6.3.2. expr length 命令

```shell
expr length "$variable"
```

+ **变量外的双引号必不可少**

### 6.4. 字符串截取

#### 6.4.1. 切片截取

类似于python 列表切片操作。利用索引，对字符串进行切片操作。

```shell
${string:beg:count}
```

+ 字符串字符索引从 0 开始
+ `string` ： 要被截取的字符串变量
+ `beg` ： 截取操作开始的索引
+ `count` ： 要截取的字符数量
+ 上述截取的是字符串中 `[beg, beg+count)` 部分的字符，长度为 `count`

#### 6.4.2. 子串匹配截取

将匹配到的字符子串删除，保留剩余字符。

##### 6.6.3. \# 语句

以 `string` 中**最左侧**的 `substring` 子串索引为边界，**删除左边字符（包括 `substring`），保留右边字符**。

```shell
string#*substring
```

+ `string` ：要被截取的字符串
+ `#` ：字符串截取符号
+ `*substring` ：模式
+ **从左往右删除，将匹配到的字符子串中最短的子串删除，保留剩余字符。**

##### 6.6.4. \#\# 语句

以 `string` 中**最右侧**的 `substring` 子串索引为边界，**删除左边字符（包括 `substring`），保留右边字符**。

```shell
string##*substring
```

+ `string` ：要被截取的字符串
+ `##` ：字符串截取符号
+ `*substring` ：模式
+ **从左向右删除，按匹配到的字符子串中最长的子串删除，保留剩余字符。**

##### 6.6.5. \% 语句

以 `string` 中**最右侧**的 `substring` 子串索引为边界，**保留左边字符，删除右边字符（包括 `substring`）**。

```shell
string%substring*
```

+ `string` ：要被截取的字符串
+ `%` ：字符串截取符号
+ `substring*` ：模式
+ **从右向左删除，按匹配到的字符子串中最短的子串删除，保留剩余字符。**

##### 6.6.6. \%\% 语句

以 `string` 中**最左侧**的 `substring` 子串索引为边界，**保留左边字符，删除右边字符（包括 `substring`）**。

```shell
string%%substring*
```

+ `string` ：要被截取的字符串
+ `%%` ：字符串截取符号
+ `substring*` ：模式
+ **从右向左删除，按匹配到的字符子串中最长的子串删除，保留剩余字符。**

|  符号  |       语法       | 效果                     |
| :--: | :------------: | ---------------------- |
| `#`  |   `string#`    | 从左边开始删除，从左边删除到第一个指定字符  |
| `##` | `string##subs` | 从左边开始删除，从左边删除到最后一个指定字符 |
| `%`  | `string%subs`  | 从右边开始删除，从右边删除到第一个指定字符  |
| `%%` | `string%%subs` | 从右边开始删除，从右边删除到最后一个指定字符 |

### 6.5. 字符替换

#### 6.5.1. \/ 语句

将字符串中的一段子串替换为指定字符串。

```shell
${string/subs/value}
```

+ `string`：要操作的字符串
+ `subs`：要被替换掉的字符子串
+ `value`：替换内容
+ 将替换内容置空，则字符替换操作等价于删除操作。
+ 只将字符串中最左侧的子串替换掉。

#### 6.5.2. \/\/ 语句

```shell
${string//subs/value}
```

+ 贪婪替换，将字符串中所有的子串都替换掉。

### 6.6. 变量的替代

#### 6.6.1. \- 语句

为变量提供默认值

+ 如果变量未被定义（包括 `unset`），则将会被替换为 `value`。
+ 如果变量已经被定义，即使为空值，也不会被替换。

```shell
${variable-value}
```

+ `variable` : 要被替换掉的变量
+ `value` ： 新值

#### 6.6.2. \:\- 语句

将没有值的变量替换成新值

+ 如果变量未被定义（包括 `unset`），或为空值，则将会被替换为 `value`。
+ 如果变量有值，也不会被替换。

```shell
${variable:-value}
```

+ `variable` : 要被替换掉的变量
+ `value` ： 新值

#### 6.6.3. \+ 语句

将已被定义的变量替换成新值

+ 如果变量已经被定义，包括空值，则替换成 `value`。
+ 如果变量未被定义（包括 `unset`），或被 `unset`，则不会替换。

```shell
${variable+value}
```

+ `variable` : 要被替换掉的变量
+ `value` ： 新值

#### 6.6.4. \:\+ 语句

将已有值的变量替换成新值

+ 如果变量有值，则替换成 `value`。
+ 如果变量未被定义（包括 `unset`），或为空值，则不会替换。

```shell
${variable+value}
```

+ `variable` : 要被替换掉的变量
+ `value` ： 新值

#### 6.6.5. \= 符号

#### 6.6.6. \:\= 符号

#### 6.6.7. \? 符号

#### 6.6.8. \:\? 符号

### 6.7. 查找子串

```shell
expr index "variable_name" sub_string
```

+ 在 `variable_name` 中查找 `sub_string` 中的字符位置，返回最靠前的位置

## 7. declare 命令

**`declare`** 是 Bash 中的内置命令，用于声明变量并设置其属性。

语法

```shell
declare [options] variable_name[=value]
```

`[options]`

+ `-i`：将变量声明为整数类型。
+ `-a`：声明变量为数组。
+ `-r`：将变量设为只读。
+ `-x`：将变量导出为环境变量。
+ `-A`：声明关联数组

>[!note]
>+ 未使用 declare 声明的变量，Shell 会将变量视为字符串变量。
>+ typeset 是与 declare 功能类似的命令，但在一些旧版本 Shell（如 KornShell）中更常用。
>	+ 在现代 Bash 中，typeset 是 declare 的别名。

### 7.1. 查看数组

```shell
# 查看所有的普通数组
declare -a

# 查看所有的关联数组
declare -A
```

## 8. 整型变量

使用`declare -i`可以将变量声明为整型

```shell
declare -i variable_name=value
```

### 8.1. 自动类型转换

+ 若value为非整数，则将保留其整数部分，舍弃非整数部分
+ 若value为完全非整数，也就是其中没有整数部分，则默认为0

### 8.2. 部分 Shell 支持

`declare` 和 `typeset` 通常用于 Bash 或 KornShell，其他 Shell（如 Dash）可能不支持。检查shell 是否支持：

```shell
declare -i test_var=10
if [ $? -eq 0 ]; then
  echo "支持 declare 命令"
else
  echo "不支持 declare 命令"
fi
```

### 8.3. 支持数学运算

整型变量可以直接进行数学运算

```shell
declare -i num=5

num=$num+5

echo $num # 输出10
```

## 9. 数组变量

bash支持一维数组，并且没有限定数组的大小。

数组元素的下标由 0 开始编号。访问数组元素时要用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

### 9.1. 数组的定义

定义时，用`()`表示数组，数组元素用`空格`分割。

语法：

```shell
# 1 
variable=(value1 value2 value3 ...)

# 2
variable=file # 将文件中每一行作为一个元素赋值给数组
```

除此之外，还可以单独定义数组中的每一个分量

```shell
# 2
variable[index]=value
```

+ 下标可以不连续，而且没有范围限制
+ value可以为变量

### 9.2. 数组元素访问

语法

```shell
${vairable_name[index]}
```

+ index 可以为变量

### 9.3. 切片访问

```shell
${variable[@]:beg:count}
```

+ 从 beg 开始，获取 count 个元素

### 9.4. 关联数组

类似于其他语言中的字典，指定key-value对

语法

```shell
# 单行
declare -A variable=(["k1"]="v1" ["k2"]="v2" ...)
# 多行
declare -A variable
variable["k1"]="v1"
variable["k2"]="v2"
...

# 通过 declare 关键字定义
declare -A variable
```

+ 键是唯一的

### 9.5. 关联数组元素的访问

通过key来访问关联数组元素

```shell
$variable["key"]
```

### 9.6. 获取全部数组元素

使用 `@` 或 `*` 可以获取数组中的所有元素

```shell
${variable_name[*]}
${variable_name[@]}
```

### 9.7. 获取数组所有的索引

在数组名字前加一个感叹号 `!` 可以**获取数组的所有键**

```shell
${!variable_name[*]}
${!variable_name[@]}
```

### 9.8. 获取数组长度

获取数组长度和获取字符串长度方法一样

```shell
${#variable_name[@]}
# or
${#variable_name[*]}
```

## 10. Shell注释

### 10.1. 单行注释

以`#`开头的行为注释，会被解释器省略

### 10.2. 多行注释

Here 文档

```shell
:<<EOF
...
EOF
```

+ `:`是空命令，用于执行后面的 Here 文档
+ `<<'EOF'` 表示开启Here 文档
+ `EOF` 是Here 文档的标识符，两个标识符之间的内容会被视为注释不会执行

实例

```shell
# 1
:<<'COMMENT'
...
COMMENT

# 2
:<<'
...
'

# 3
:<<!
...
!
```

直接使用`:`号

语法

```shell
# : + 空格 + ' 
# .. 
# '
: '
...
...
'
```

+ `:`和`'`之间有一个空格

## 11. 表达式

整数运算

`[]`表达式

注意：在 `[]` 表达式中，常见的 >, < 需要加转义字符，表示字符串大小比较，以 `acill` 码位置作为比较。不直接支持 >, < 运算符，还有逻辑运算符 || 、&& ，它需要用 -a[and] –o[or] 表示。

`[[]]`表达式

注意：`[[]]` 运算符只是 `[]` 运算符的扩充。能够支持 >, < 符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| && ，不再使用 -a -o。

`$()`

`` `expr ` ``

### 11.1. 命令替换语法

1 反引号 `` ` ` ``

字符串被以用反引号包裹后，会将内容作为命令执行，并输出其结果。

2 `$()`

与反引号相同作用，但在可读性和灵活性上比反引号更好。**推荐**

## 12. 运算

### 12.1. 表达式

#### 12.1.1. expr 运算式

使用 `expr` 命令

```shell
res=`expr 表达式`

res=`expr $a + $b`
res=`expr $a - $b`
res=`expr $a \* $b`
res=`expr $a / $b`
res=`expr $a % $b`
```

+ 上述是反引号
+ epxr 运算符之间必须有空格

#### 12.1.2. $((运算式))

```shell
res=$((表达式))

res=$(($a+$b))
res=$(($a-$b))
res=$(($a*$b))
res=$(($a/$b))
res=$(($a%$b))
res=$(($a**$b))
```

#### 12.1.3. $[运算式]

等价于 `$(())`

```shell
res=$((表达式))

res=$[$a+$b]
res=$[$a-$b]
res=$[$a*$b]
res=$[$a/$b]
res=$[$a%$b]
res=$[$a**$b]
```

#### 12.1.4. let 运算式

```shell
let 表达式

let sum=$a+$b
let $a++
```

### 12.2. 整数算术运算符

| 运算符 | 说明  | 语法                    | 补充             |
| --- | --- | --------------------- | -------------- |
| `+` | 加法  | `` `expr $a + $b` ``  |                |
| `-` | 减法  | `` `expr $a - $b` ``  |                |
| `*` | 乘法  | `` `expr $a \* $b` `` | 在 expr 运算中需要转义 |
| `/` | 除法  | `` `expr $a / $b` ``  |                |
| `%` | 取余  | `` `expr $a % $b` ``  |                |

### 12.3. 整数关系运算符

条件运算符

| 运算符   | 说明                                  | 语法              |
| ----- | ----------------------------------- | --------------- |
| `-eq` | equal，检测两个数是否相等                     | `[ $a -eq $b ]` |
| `-ne` | not equal，检测两个数是否不等                 | `[ $a -ne $b ]` |
| `-gt` | greater than，检测左边数是否大于右边            | `[ $a -gt $b ]` |
| `-lt` | less than，检测左边数是否小于右边               | `[ $a -lt $b ]` |
| `-ge` | greater than or equal，检测左边数是否大于等于右边 | `[ $a -ge $b ]` |
| `-le` | less than or equal，检测左边数是否小于等于右边    | `[ $a -le $b ]` |
|       |                                     |                 |

### 12.4. 字符串运算符

字符条件运算符

| 运算符      | 说明                    | 语法             | 补充                       |
| -------- | --------------------- | -------------- | ------------------------ |
|  `=`     | 检测两个字符串是否相等           | `[ $a = $b ]`  |                          |
| `!=`     | 检测两个字符串是否不等           | `[ $a != $b ]` |                          |
| `>`      | 检测左边字符串是否大于右边         | `[ $a \> $b ]` |                          |
| `<`      | 检测左边字符串是否小于右边         | `[ $a \< $b ]` |                          |
| `-z`     | zero，检测字符串长度是否为0      | `[ -z $a ]`    |                          |
| `-n`<br> | not zero，检测字符串长度是否不为0 | `[ -n "$a" ]`  | 若变量外没有双引号包裹，则永远返回 `true` |
| `$`      | 检测字符串是否不为空            | `[ $a ]`       |                          |

> [!note] 不同类型进行比较使用的操作符不一样
> + 字符串比较：`=`、`==`
> + 整数比较：`-eq`、`==`

### 12.5. 文件测试运算符

| 符号                | 功能                   | 补充         |
| ----------------- | -------------------- | ---------- |
| `file1 -nt file2` | file1 是否比 file2 更新   | newer than |
| `file1 -ot file2` | file1 是否比 file2 更老   | older than |
| `-c file`         | 检测文件是否存在，且是字符设备文件    |            |
| `-d file`         | 检测文件是否存在，且为目录        |            |
| `-f file`         | 检测文件是否存在，且为普通文件      |            |
| `-h file`         | 检测文件是否存在，并且是符号链接     | `-L file`  |
| `-p file`         | 检测文件是否存在，且是一个有名管道    |            |
| `-S file`         | 检测文件是否存在，且是一个 socket |            |
| `-g file`         | 检测文件是否设置了 SGID 位     |            |
| `-k file`         | 检测文件是否设置类黏着位         |            |
| `-u file`         | 检测文件是否设置了 SUID 位     |            |
| `-r file`         | 检测文件是否存在，且可读         |            |
| `-w file`         | 检测文件是否存在，且可写         |            |
| `-x file`         | 检测文件是否存在，且可执行        |            |
| `-s file`         | 检测文件是否为空             | 文件大小是否大于0  |
| `-e file`         | 检测文件（包括目录）是否存在       |            |

### 12.6. 布尔运算符

用在表达式上的

| 运算符  | 说明    | 语法                   |
| ---- | ----- | -------------------- |
| `!`  | 非     | `[ ! expr ]`         |
| `-o` | or，或  | `[ expr1 -o expr2 ]` |
| `-a` | and，与 | `[ expr1 -a expr2 ]` |

### 12.7. 逻辑运算符

| 运算符    | 说明    | 语法                       |
| ------ | ----- | ------------------------ |
| `&&`   | 逻辑AND | `[[ expr1 && expr2 ]]`   |
| `\|\|` | 逻辑OR  | `[[ expr1 \|\| expr2]]` |

## 13. 输入输出重定向

### 13.1. 文件描述符号

| 符号  | 功能          | 补充        |
| --- | ----------- | --------- |
| `0` | stdin，标准输入  | 键盘输入      |
| `1` | stdout，标准输出 | 默认输出到屏幕   |
| `2` | stderr，标准错误 | 错误信息输出到屏幕 |

### 13.2. 重定向符号

| 符号           | 功能                       | 补充      |
| ------------ | ------------------------ | ------- |
| `>`          | 覆盖方式写入文件。                | 输出重定向   |
| `>>`         | 追加方式写入文件。                | 输出重定向   |
| `<`          | 读取文件内容。<br>              | 输入重定向   |
| `2>`         | 重定向标准错误输出到文件（覆盖方式）。      |         |
| `2>>`        | 重定向标准错误输出到文件（追加方式）。      |         |
| `&>`         | 同时重定向标准输出和标准错误到同一文件（覆盖）。 |         |
| `<>`         | 打开文件用于读写                 |         |
| `>file 2>&1` | 重定向标准输出和标准错误到同一文件        |         |
| `\|`         | 管道符，将左边命令的输出作为右边命令的输入    | 输入输出重定向 |

### 13.3. 管道符

将管道符左边命令的输出作为管道符右边命令的输入

语法

```shell
command1 | command2 | ...
```

### 13.4. 输出重定向

通过 **重定向符** 将 `echo` 输出保存到文件中：

```shell
echo [options] string [重定向符 filename]
```

### 13.5. `2>&1` 和 `&>` 的异同

| 特性       | `2>&1`       | `&>`                    |
| -------- | ------------ | ----------------------- |
| 作用       | 重定向标准错误到标准输出 | 同时重定向标准输出和标准错误          |
| Shell 支持 | 兼容性高         | Bash 和 Zsh 支持，但其他的不一定支持 |
| 顺序敏感性    | 顺序影响效果       | 顺序不敏感                   |

```shell
# 正确
command > file 2>&1
```

+ 标准输出先被重定向到 `file`，然后标准错误也被重定向到标准输出（即同样写入 `file`）。

```shell
# 错误
command 2>&1 > file
```

+ 标准错误先被重定向到当前的标准输出（通常是终端），然后标准输出被重定向到 `file`。最终结果是标准错误仍然输出到终端。

### 13.6. 输入重定向

```shell
cat < /path/of/file
```

### 13.7. Here 文档

将输入的内容，交给命令指向

```shell
/path/of/command <<-EOF [> filename]
comand...
EOF
```

## 14. 别名功能

### 14.1. alias

### 14.2. unalias

## 15. 条件测试

### 15.1. test 测试命令

用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

#### 15.1.1. 数值测试

语法

```shell
test $v1 OP $v2
```

OP：shell 风格的逻辑运算符

+ `-gt`
+ `-ge`
+ `-lt`
+ `-le`
+ `-eq`
+ `-ne`

### 15.2. 字符串测试

语法

```shell
test $v1 options1 $v2


```

```shell
test options $v
```

+ `-n`：长度非0
+ `-z`:长度为0

#### 15.2.1. 文件测试

```shell
test OP file
```

### 15.3. \[\] 符号

```shell
[ OPTIONS EXPRESSION ]
```

+ `[`：可以看作 **test 命令的别名**
+ `]`：是 `[` 命令必有的一个参数
+ 因此，`[`和`]`与表达式之间必须要有空格

>[!note]
>`test` 命令和`[` 命令是几乎一样的命令

### 15.4. \[\[\]\] 符号

### 15.5. (()) 符号

C风格的数值比较

```shell
(($var1OP$var2))
```

OP：C风格的逻辑运算符

+ `>`
+ `>=`
+ `<`
+ `<=`
+ `==`
+ `!=`

## 16. 条件控制

### 16.1. if

sh中 if 的函数体不能为空，如果条件分支中没有要执行的命令，则不要写该分支

语法

```shell
if condition
then
	command
fi

# 写法2
if condition; then
	command
fi
```

`if elif`

```shell
if condition1
then
	command
elif condition2
then
	command
else
	command
fi

# 写法2
if condition1; then
	command
elif condition2; then
	command
else
	command
fi
```

### 16.2. for

```shell
for((1; condition; 3)); do
	command
done
```

### 16.3. while 循环

```shell
while condition; do
	command
done
```

### 16.4. `break` 和 `continue`

## 17. 函数

完成特定功能的代码块。必须先定义再使用。

### 17.1. 函数定义

```shell
function_name(){
	command...
}

function name{
	command...
}
```

### 17.2. 函数调用

```shell
# 无参函数
function_name

# 有参函数
function_name argu1 argu2 ...
```

### 17.3. 函数传参

函数的传参和脚本的传参方式一样，都是通过`$n`的方式进行传参。

要注意脚本传入的参数和函数传入的参数之间的区别：

+ 脚本传参
	+ 脚本执行时
	+ shell 中的输入
	+ 脚本内变量
+ 函数传参
	+ 函数调用时
	+ 脚本内的变量
	+ 函数体内的变量

例子

```shell
func(){
	$1
	$2
}

func $1 $2
func $3 $4
```

### 17.4. 函数返回值

默认为函数内最后一条命令的执行结果。

#### 17.4.1. `return`

通过`return`关键字，可以手动指定返回值。

```shell
func_name(){
	local res
	...
	return $res
}
```

函数的返回值可以通过`$?`获取

```shell
func_name # 函数调用
echo "func return value: $?"
```

> [!note] `return` 缺点
> + 仅能返回`[0-255]`之间的整数

#### 17.4.2. `echo`

通过 echo 的方式，将需要的函数返回值，输出给某个变量

```shell
func_name(){
	local res
	...
	echo $res
}
result=$(func_name)
```

## 18. shell 内置程序的内置命令

### 18.1. \: 命令

空命令

在 while 后面返回真值

### 18.2. true 和 false

真假

### 18.3. exit

### 18.4. break 和 continue

### 18.5. shift

参数列表向左移动

代码

```shell
shift n
```

示例

```shell
#!/usr/bin/env sh
while [ $# -ne 0 ]
do
	let sum+=$1
	shift
done
echo "sum:$sum"
```
